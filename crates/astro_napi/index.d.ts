/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * Options for compiling Astro files to JavaScript.
 *
 * Some fields (such as `sourcemap`, `compact`, CSS scoping) are stubs accepted for API compatibility.
 */
export interface AstroCompileOptions {
  /**
   * The filename of the Astro component being compiled.
   * Used in the `$$createComponent` call for debugging.
   */
  filename?: string
  /**
   * A normalized version of the filename used for scope hash generation.
   * If not provided, falls back to `filename`.
   */
  normalizedFilename?: string
  /**
   * The import specifier for Astro runtime functions.
   * Defaults to `"astro/runtime/server/index.js"`.
   */
  internalUrl?: string
  /**
   * Whether to generate a source map.
   * When `true`, the `map` field in the result will contain a JSON-encoded
   * source map that maps the generated JavaScript back to the original `.astro` source.
   *
   * @default false
   */
  sourcemap?: boolean
  /**
   * Arguments passed to `$$createAstro` when the Astro global is used.
   * Defaults to `"https://astro.build"`.
   */
  astroGlobalArgs?: string
  /**
   * Whether to collapse whitespace in the HTML output.
   * **Stub**: not yet implemented.
   *
   * @default false
   */
  compact?: boolean
  /**
   * Enable scoped slot result handling.
   * When `true`, slot callbacks receive the `$$result` render context parameter.
   *
   * @default false
   */
  resultScopedSlot?: boolean
  /**
   * Strategy for CSS scoping: `"where"`, `"class"`, or `"attribute"`.
   * **Stub**: not yet implemented.
   *
   * @default "where"
   */
  scopedStyleStrategy?: string
  /**
   * URL for the view transitions animation CSS.
   * **Stub**: not yet implemented.
   */
  transitionsAnimationUrl?: string
  /**
   * Whether to annotate generated code with the source file path.
   * **Stub**: not yet implemented.
   *
   * @default false
   */
  annotateSourceFile?: boolean
  /**
   * Whether to strip HTML comments from component slot children.
   * Matches the official Astro compiler behavior by default.
   *
   * @default true
   */
  stripSlotComments?: boolean
  /**
   * Whether the caller has a `resolvePath` function.
   *
   * When `true`, the codegen will:
   * - Skip emitting `$$createMetadata` import
   * - Skip emitting `import * as $$moduleN` re-imports
   * - Skip emitting `export const $$metadata = ...`
   * - Use plain string literals instead of `$$metadata.resolvePath(...)`
   *
   * The actual path resolution is done by the JS wrapper layer using
   * the `resolvePath` callback post-compilation.
   *
   * @default false
   */
  resolvePathProvided?: boolean
  /**
   * Preprocessed style content, indexed by extractable style order.
   *
   * When provided, the codegen uses these strings as CSS content instead
   * of reading from the AST's `<style>` text children. Each entry
   * corresponds to an extractable style in document order (matching the
   * indices from `extractStylesSync`).
   *
   * An entry of `undefined` means "use the original content from the AST".
   * An entry of `""` means "style had a preprocessing error — use empty content".
   */
  preprocessedStyles?: Array<string | undefined | null>
}

/** Result of compiling an Astro file. */
export interface AstroCompileResult {
  /** The generated JavaScript code. */
  code: string
  /**
   * Source map JSON string. Contains a JSON-encoded source map when
   * `sourcemap: true` was passed in options. Empty string otherwise.
   */
  map: string
  /** CSS scope hash for the component. */
  scope: string
  /** Extracted CSS from `<style>` tags (empty until CSS support). */
  css: Array<string>
  /** Hoisted scripts extracted from the template. */
  scripts: Array<NapiHoistedScript>
  /** Components with `client:*` hydration directives (except `client:only`). */
  hydratedComponents: Array<NapiHydratedComponent>
  /** Components with `client:only` directive. */
  clientOnlyComponents: Array<NapiHydratedComponent>
  /** Components with `server:defer` directive. */
  serverComponents: Array<NapiHydratedComponent>
  /** Whether the template contains an explicit `<head>` element. */
  containsHead: boolean
  /** Whether the component propagates head content. */
  propagation: boolean
  /** Style processing errors (stub: always empty). */
  styleError: Array<string>
  /** Diagnostic messages (stub: always empty). */
  diagnostics: Array<string>
  /** Any compilation errors encountered (oxc-specific). */
  errors: Array<OxcError>
}

/** Result of parsing an Astro file into an AST. */
export interface AstroParseResult {
  /**
   * The AST serialized as a JSON string (ESTree-compatible format from oxc).
   * Call `JSON.parse()` on this to get the AST object.
   */
  ast: string
  /** Any parse errors encountered. */
  errors: Array<OxcError>
}

/**
 * Compile Astro file to JavaScript asynchronously on a separate thread.
 *
 * This transforms an Astro file into JavaScript code compatible with the Astro runtime.
 * The output follows the same format as the official Astro compiler.
 *
 * Generally `compileAstroSync` is preferable to use as it does not have the overhead
 * of spawning a thread. If you need to parallelize compilation of multiple files,
 * it is recommended to use worker threads.
 *
 * @example
 * ```javascript
 * import { compileAstro } from '@astrojs/compiler';
 *
 * const result = await compileAstro(`---
 * const name = "World";
 * ---
 * <h1>Hello {name}!</h1>`, {
 *   filename: 'Component.astro',
 * });
 *
 * console.log(result.code); // Generated JavaScript
 * ```
 */
export declare function compileAstro(sourceText: string, options?: AstroCompileOptions | undefined | null): Promise<AstroCompileResult>

/**
 * Compile Astro file to JavaScript synchronously on current thread.
 *
 * This transforms an Astro file into JavaScript code compatible with the Astro runtime.
 * The output follows the same format as the official Astro compiler.
 *
 * @example
 * ```javascript
 * import { compileAstroSync } from '@astrojs/compiler';
 *
 * const result = compileAstroSync(`---
 * const name = "World";
 * ---
 * <h1>Hello {name}!</h1>`, {
 *   filename: 'Component.astro',
 * });
 *
 * console.log(result.code); // Generated JavaScript
 * ```
 */
export declare function compileAstroSync(sourceText: string, options?: AstroCompileOptions | undefined | null): AstroCompileResult

export interface ErrorLabel {
  message: string | null
  start: number
  end: number
  /** 1-based line number in the source. */
  line: number
  /** 0-based column number in the source. */
  column: number
}

/**
 * Extract style block metadata from an Astro source without performing compilation.
 *
 * Returns an array of style blocks in document order. Each block contains the
 * text content and attributes of an extractable `<style>` element.
 *
 * This is the first step in the "Rust extract → TS preprocess → Rust compile"
 * pipeline for `preprocessStyle` support.
 */
export declare function extractStylesSync(sourceText: string): Array<NapiStyleBlock>

/** A hoisted script extracted from an Astro component. */
export interface NapiHoistedScript {
  /** The script type: `"inline"` or `"external"`. */
  type: string
  /** The inline script code (when type is `"inline"`). */
  code?: string
  /** The external script src URL (when type is `"external"`). */
  src?: string
}

/** A hydrated component reference found in the template. */
export interface NapiHydratedComponent {
  /** The export name from the module (e.g., `"default"`). */
  exportName: string
  /** The local variable name used in the component. */
  localName: string
  /** The import specifier (e.g., `"../components/Counter.jsx"`). */
  specifier: string
  /** The resolved path (empty string if unresolved). */
  resolvedPath: string
}

/**
 * An extractable `<style>` block from an Astro component.
 *
 * Returned by `extractStylesSync` for each `<style>` element that would be
 * extracted and processed during compilation.
 */
export interface NapiStyleBlock {
  /** Zero-based index of this style block among all extractable styles. */
  index: number
  /** The CSS/preprocessor text content between `<style>` and `</style>`. */
  content: string
  /**
   * The element's attributes as key-value pairs.
   * Only quoted and empty (boolean) attributes are included — expression
   * attributes (like `define:vars={...}`) are omitted.
   */
  attrs: Record<string, string>
}

export interface OxcError {
  severity: Severity
  message: string
  labels: Array<ErrorLabel>
  helpMessage: string | null
  codeframe: string | null
}

/**
 * Parse an Astro file into an AST asynchronously on a separate thread.
 *
 * Returns the oxc AST in ESTree-compatible JSON format.
 */
export declare function parseAstro(sourceText: string): Promise<AstroParseResult>

/**
 * Parse an Astro file into an AST synchronously.
 *
 * Returns the oxc AST in ESTree-compatible JSON format.
 *
 * @example
 * ```javascript
 * import { parseAstroSync } from '@astrojs/compiler';
 *
 * const { ast } = parseAstroSync(`---
 * const name = "World";
 * ---
 * <h1>Hello {name}!</h1>`);
 *
 * const tree = JSON.parse(ast);
 * console.log(tree.type); // "AstroRoot"
 * ```
 */
export declare function parseAstroSync(sourceText: string): AstroParseResult

export declare const enum Severity {
  Error = 'Error',
  Warning = 'Warning',
  Advice = 'Advice'
}
