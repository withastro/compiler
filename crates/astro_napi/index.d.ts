/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * Compile Astro file to JavaScript asynchronously on a separate thread.
 *
 * Generally `compileAstroSync` is preferable to use as it does not have the overhead
 * of spawning a thread. If you need to parallelize compilation of multiple files,
 * it is recommended to use worker threads.
 *
 * @example
 * ```javascript
 * import { compileAstro } from '@astrojs/compiler-binding';
 *
 * const result = await compileAstro(`---
 * const name = "World";
 * ---
 * <h1>Hello {name}!</h1>`, {
 *   filename: 'Component.astro',
 * });
 *
 * console.log(result.code); // Generated JavaScript
 * ```
 */
export declare function compileAstro(sourceText: string, options?: CompileOptions | undefined | null): Promise<CompileResult>

/**
 * Compile Astro file to JavaScript synchronously on current thread.
 *
 * @example
 * ```javascript
 * import { compileAstroSync } from '@astrojs/compiler-binding';
 *
 * const result = compileAstroSync(`---
 * const name = "World";
 * ---
 * <h1>Hello {name}!</h1>`, {
 *   filename: 'Component.astro',
 * });
 *
 * console.log(result.code); // Generated JavaScript
 * ```
 */
export declare function compileAstroSync(sourceText: string, options?: CompileOptions | undefined | null): CompileResult

/** Options for compiling Astro files to JavaScript. */
export interface CompileOptions {
  /**
   * The filename of the Astro component being compiled.
   * Used in the `$$createComponent` call for debugging.
   */
  filename?: string
  /**
   * A normalized version of the filename used for scope hash generation.
   * If not provided, falls back to `filename`.
   */
  normalizedFilename?: string
  /**
   * The import specifier for Astro runtime functions.
   * Defaults to `"astro/runtime/server/index.js"`.
   */
  internalURL?: string
  /**
   * Source map generation mode.
   *
   * - `"external"`: populate the `map` field with a JSON source map.
   * - `"inline"`: append an inline `//# sourceMappingURL=data:...` comment; `map` will be empty.
   * - `"both"`: append the inline comment **and** populate `map`.
   * - `undefined`: no source map (default).
   */
  sourcemap?: 'external' | 'inline' | 'both'
  /**
   * Arguments passed to `$$createAstro` when the Astro global is used.
   * Defaults to `"https://astro.build"`.
   */
  astroGlobalArgs?: string
  /**
   * Whether to collapse whitespace in the HTML output.
   * **Stub**: not yet implemented.
   *
   * @default false
   */
  compact?: boolean
  /**
   * Enable scoped slot result handling.
   * When `true`, slot callbacks receive the `$$result` render context parameter.
   *
   * @default false
   */
  resultScopedSlot?: boolean
  /**
   * Strategy for CSS scoping.
   *
   * @default "where"
   */
  scopedStyleStrategy?: 'where' | 'class' | 'attribute'
  /**
   * URL for the view transitions animation CSS.
   * When set, replaces the default `"transitions.css"` bare specifier in the emitted import.
   */
  transitionsAnimationURL?: string
  /**
   * Whether to annotate generated code with the source file path.
   * **Stub**: not yet implemented.
   *
   * @default false
   */
  annotateSourceFile?: boolean
  /**
   * Whether to strip HTML comments from component slot children.
   * Matches the official Astro compiler behavior by default.
   *
   * @default true
   */
  stripSlotComments?: boolean
  /**
   * Whether the caller has a `resolvePath` function.
   *
   * When `true`, the codegen will:
   * - Skip emitting `$$createMetadata` import
   * - Skip emitting `import * as $$moduleN` re-imports
   * - Skip emitting `export const $$metadata = ...`
   * - Use plain string literals instead of `$$metadata.resolvePath(...)`
   *
   * The actual path resolution is done by the JS wrapper layer using
   * the `resolvePath` callback post-compilation.
   *
   * @default false
   */
  resolvePathProvided?: boolean
  /**
   * Preprocessed style content, indexed by extractable style order.
   *
   * When provided, the codegen uses these strings as CSS content instead
   * of reading from the AST's `<style>` text children. Each entry
   * corresponds to an extractable style in document order (matching the
   * indices from `extractStylesSync`).
   *
   * An entry of `undefined` means "use the original content from the AST".
   * An entry of `""` means "style had a preprocessing error — use empty content".
   */
  preprocessedStyles?: Array<string | undefined | null>
}

export interface CompilerError {
  severity: 'error' | 'warning' | 'hint'
  message: string
  labels: Array<CompilerErrorLabel>
  helpMessage: string | null
  codeframe: string | null
}

export interface CompilerErrorLabel {
  message: string | null
  start: number
  end: number
  /** 1-based line number in the source. */
  line: number
  /** 0-based column number in the source. */
  column: number
}

/** Result of compiling an Astro file. */
export interface CompileResult {
  /** The generated JavaScript code. */
  code: string
  /**
   * Source map JSON string. Contains a JSON-encoded source map when
   * `sourcemap: true` was passed in options. Empty string otherwise.
   */
  map: string
  /** CSS scope hash for the component. */
  scope: string
  /** Extracted CSS from `<style>` tags. */
  css: Array<string>
  /** Hoisted scripts extracted from the template. */
  scripts: Array<HoistedScript>
  /** Components with `client:*` hydration directives (except `client:only`). */
  hydratedComponents: Array<Component>
  /** Components with `client:only` directive. */
  clientOnlyComponents: Array<Component>
  /** Components with `server:defer` directive. */
  serverComponents: Array<Component>
  /** Whether the template contains an explicit `<head>` element. */
  containsHead: boolean
  /** Whether the component propagates head content. */
  propagation: boolean
  /** Style processing errors. */
  styleError: Array<string>
  /** Diagnostic messages. */
  diagnostics: Array<string>
  /** Any compilation errors encountered. */
  errors: Array<CompilerError>
}

/** A component reference found in the template (hydrated, client-only, or server-deferred). */
export interface Component {
  /** The export name from the module (e.g., `"default"`). */
  exportName: string
  /** The local variable name used in the component. */
  localName: string
  /** The import specifier (e.g., `"../components/Counter.jsx"`). */
  specifier: string
  /** The resolved path (empty string if unresolved). */
  resolvedPath: string
}

/**
 * Extract style block metadata from an Astro source without performing compilation.
 *
 * Returns an array of style blocks in document order. Each block contains the
 * text content and attributes of an extractable `<style>` element.
 *
 * This is the first step in the "Rust extract → TS preprocess → Rust compile"
 * pipeline for `preprocessStyle` support.
 */
export declare function extractStylesSync(sourceText: string): Array<StyleBlock>

/** A hoisted script extracted from an Astro component. */
export interface HoistedScript {
  /** The script type: `"inline"` or `"external"`. */
  type: string
  /** The inline script code (when type is `"inline"`). */
  code?: string
  /** The external script src URL (when type is `"external"`). */
  src?: string
}

/**
 * Parse an Astro file into an AST asynchronously on a separate thread.
 *
 * Returns the oxc AST in ESTree-compatible JSON format.
 */
export declare function parseAstro(sourceText: string): Promise<ParseResult>

/**
 * Parse an Astro file into an AST synchronously.
 *
 * Returns the oxc AST in ESTree-compatible JSON format.
 *
 * @example
 * ```javascript
 * import { parseAstroSync } from '@astrojs/compiler-binding';
 *
 * const { ast } = parseAstroSync(`---
 * const name = "World";
 * ---
 * <h1>Hello {name}!</h1>`);
 *
 * const tree = JSON.parse(ast);
 * console.log(tree.type); // "AstroRoot"
 * ```
 */
export declare function parseAstroSync(sourceText: string): ParseResult

/** Result of parsing an Astro file into an AST. */
export interface ParseResult {
  /**
   * The AST serialized as a JSON string (ESTree-compatible format from oxc).
   * Call `JSON.parse()` on this to get the AST object.
   */
  ast: string
  /** Any parse errors encountered. */
  errors: Array<CompilerError>
}

/**
 * Strategy for CSS scoping.
 *
 * Determines how Astro scopes CSS selectors to components.
 */
export declare const enum ScopedStyleStrategy {
  /** Use `:where(.astro-XXXX)` selector (default). */
  Where = 'where',
  /** Use `.astro-XXXX` class selector. */
  Class = 'class',
  /** Use `[data-astro-cid-XXXX]` attribute selector. */
  Attribute = 'attribute'
}

export declare const enum Severity {
  Error = 'error',
  Warning = 'warning',
  Hint = 'hint'
}

/** Controls whether and how source maps are emitted. */
export declare const enum SourcemapOption {
  /** Generate a source map in the `map` field of the result. */
  External = 'external',
  /**
   * Append an inline `//# sourceMappingURL=data:...` comment to the code.
   * The `map` field will be empty.
   */
  Inline = 'inline',
  /** Both: append the inline comment **and** populate the `map` field. */
  Both = 'both'
}

/**
 * An extractable `<style>` block from an Astro component.
 *
 * Returned by `extractStylesSync` for each `<style>` element that would be
 * extracted and processed during compilation.
 */
export interface StyleBlock {
  /** Zero-based index of this style block among all extractable styles. */
  index: number
  /** The CSS/preprocessor text content between `<style>` and `</style>`. */
  content: string
  /**
   * The element's attributes as key-value pairs.
   * Only quoted and empty (boolean) attributes are included — expression
   * attributes (like `define:vars={...}`) are omitted.
   */
  attrs: Record<string, string>
}
